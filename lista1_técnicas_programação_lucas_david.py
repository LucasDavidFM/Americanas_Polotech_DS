# -*- coding: utf-8 -*-
"""Lista1_técnicas_programação-Lucas_David

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13Fi4daALGDFglqgSbcuEIRDxZVOTj6IP

# Aula 03 - NumPy (Parte II)

<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/31/NumPy_logo_2020.svg/2560px-NumPy_logo_2020.svg.png" alt="Alternative text" />

[Guia rápido de uso da biblioteca](https://numpy.org/devdocs/user/quickstart.html)

[Guia para iniciantes](https://numpy.org/devdocs/user/absolute_beginners.html)

Na aula passada, vimos que:

- um **array** é o elemento básico por meio do qual a biblioteca *numpy* opera;
- este elemento **difere de uma lista**, por ser homogêneo e possibilitar cálculos de uma maneira altamente eficiente;
- a **indexação** de arrays é muito similar àquela de listas;
- a biblioteca *numpy* fornece ferramentas para gerar arrays baseados em distribuições estatísticas (como uniforme e normal) de maneira aleatória;
- existem diversos métodos que sumarizam alguamas propriedades dos vetores, como *.mean()*, *.std()*, entre outros.

Na aula de hoje, vamos explorar os conceitos de **filtros** e de **matrizes** com numpy.

___

#### Filtros (máscaras)

Uma das funções mais importantes do numpy é a possibilidade de construção de **filtros**, que também são chamados de **máscaras**

O objetivo dos filtros é **selecionar apenas os elementos de um array que satisfaçam determinada condição**
"""

# definindo um array aleatoriamente
import numpy as np
arr = np.random.rand(20)
arr

"""Ao usar um **operador lógico** juntamente com um array, o numpy **aplica a operação lógica a cada um dos elementos do array**, retornando um **array de bools** com o resultado de cada uma das operações lógicas:"""

# quais elementos do array são menores que 0.5?
arr < 0.5

# Quantos elementos são maiores que 0.5?
(arr > 0.5)

(arr > 0.5).size

(arr > 0.5).sum()

"""Uma vez criado o filtro, é possível **utilizá-lo como indexador do array**, para selecionar **apenas os elementos com indice correspondente a True no filtro**"""

arr

# quero elementos do "arr" que satisfaçam uma dada condição (ser menor que 0.5)
arr[arr < 0.5]

# quero elementos do "arr" que satisfaçam uma dada condição (ser maior que 0.5)
arr[arr > 0.5]

# quero elementos do "arr" que satisfaçam uma dada condição (ser igual a 0.5)
arr[arr == 0.5]

"""Mais um exemplo..."""

# definindo um novo array aleatório de inteiros

ints = np.random.randint(0, 100, 20)
ints

# filtrando apenas os pares
ints[ints % 2 == 0]

# filtrando apenas os ímpares
ints[ints % 2 != 0]

# filtrando apenas os ímpares
ints[~(ints % 2 == 0)]

# quantidade de ímpáres
ints[~(ints % 2 == 0)].size

# soma dos ímpáres
ints[~(ints % 2 == 0)].sum()

"""[np.where](https://numpy.org/doc/stable/reference/generated/numpy.where.html)"""

ints

# Filtro para ser par
np.where(ints % 2 == 0, ints, np.nan)

a = 10
~ a > 1

"""Também é possível aplicar **filtros compostos**!

Pra fazer isso, nós fazems uma **composição lógica** entre os filtros (análogo ao "and" e ao "or")

No caso de arrays, usamos:

- "&" para "and"
- "|" para "or"
- "~" para "not"
"""

# filtrar divisíveis por 2 e maiores que 50
(ints % 2 == 0) & (ints > 50)

# filtrar divisíveis por 2 e maiores que 50
ints[(ints % 2 == 0) & (ints > 50)]

# filtrar divisíveis por 2 OU maiores que 50
ints[(ints % 2 == 0) | (ints > 50)]

# filtrar ímpares OU maiores que 50
ints[~ (ints % 2 == 0) | (ints > 50)]

"""___

### Matrizes

Costumamos nos referir às **matrizes** como arrays multidimensionais (i.e., mais de uma dimensão).

<img src = "https://numpy.org/devdocs/_images/np_create_matrix.png" />
"""

data = np.array([[1,2],[3,4],[5,6]])
data

"""[numpy.shape](https://numpy.org/doc/stable/reference/generated/numpy.shape.html)"""

data.size

# Retorna o formato da matriz como numero_de_linhas x numero_de_colunas
data.shape

"""#### Indexação de matrizes

A idexação com matrizes segue a mesma lógica dos arrays. Há algumas formas de indexar o mesmo elemento, conforme ilustrado abaixo.

Suponhamos que queiramos o elemento da segunda linha da matriz, e da segunda coluna.
"""

data

# ordem: linha, coluna
data[1,1]

"""Alternativamente, podemos indexar o mesmo elemento escrevendo:"""

data[1][1]

"""<img src = "https://numpy.org/devdocs/_images/np_matrix_indexing.png" />

#### Agregações

Similarmente a como fizemos com **arrays**, também podemos aplicar **funções de agregação** às matrizes:
"""

data

data.max()

data.min()

data.sum()

"""<img src = "https://numpy.org/devdocs/_images/np_matrix_aggregation.png" />

Também podemos ter situações em que gostaríamos de **agregar por linhas e/ou colunas**, o que também é possível, especificando o parâmetro *axis*, conforme abaixo.
"""

data

# "axis = 0" opera na direção das colunas, avaliando entre linhas
data.max(axis = 0)

# "axis = 1" opera na direação das linhas, avaliando entre colunas
data.max(axis = 1)

"""<img src = "https://numpy.org/devdocs/_images/np_matrix_aggregation_row.png" />

[numpy.reshape](https://numpy.org/doc/stable/reference/generated/numpy.reshape.html)

Em algumas situações, pode ser útil **reformatar** nosso conjunto de dados. Para isso, utilizamos a função *.reshape()*.
"""

# Vamos supor um vetor de 10 elementos
dados_originais = np.arange(0,10)
dados_originais

# Vamos transformá-lo em uma matriz de duas linhas
dados_reformatados = np.reshape(dados_originais, [2,5])
dados_reformatados

dados_reformatados.shape

# Vamos transformá-lo em uma matriz de duas colunas
dados_reformatados = np.reshape(dados_originais, [5,2])
dados_reformatados

dados_reformatados.shape

"""**Atenção:** ao utilizar o reshape, o número de elementos total nunca pode ser alterado!"""

np.reshape(dados_originais, [3,3])

"""<img src = "https://numpy.org/devdocs/_images/np_reshape.png" />

#### Operações com matrizes
"""

matriz1 = np.array([[1,2], [3,4]])
matriz2 = np.array([[5,4], [-2,0]])
matriz1+matriz2

print(matriz1)
print(matriz2)

"""<img src="https://numpy.org/devdocs/_images/np_matrix_arithmetic.png" />

Diferentemente com arrays unidimensionais, conseguimos operar com matriz de tamanhos diferentes, **desde que sejam essencialmente um vetor-linha ou um vetor-coluna**.
"""

array1 = [1,1]
matriz1 + array1

"""<img src = "https://numpy.org/devdocs/_images/np_matrix_broadcasting.png" />"""

print(matriz1)
print(matriz2)

# multiplicação elemento a elemento
matriz1 * matriz2

# multiplicação de matrizes "tradicional"
matriz1.dot(matriz2)

"""Transpor a matriz equivale a "trocar" as linhas pelas colunas."""

data

data.transpose()

"""<img src = "https://numpy.org/devdocs/_images/np_transposing_reshaping.png" />

#### Filtrando matrizes

Seguimos a mesma lógica de filtros em arrays unidimensionais, com a particularidade de que estamos lidando, agora, com mais de uma dimensão - e podemos levar isso em consideração.
"""

data

# filtrando a matriz como um todo
data > 2

data

# filtrando o primeiro elemento de cada coluna
data[0,:] > 1

# filtrando o segundo elemento de cada linha
data[:,1] > 4

"""Assim como fizemos anteriromente, podemos utilizar esse array booleano para indexar a matriz original."""

data

data[data[:,1] > 4]

"""Um outro exemplo"""

# Vamos gerar uma matriz 4 x 4 aleatoriamente
matriz = np.random.randn(4,4)
matriz

matriz[:,1]

# Filtremos todas as linhas cuja segunda coluna seja positiva
matriz[:,1] > 0

matriz[:,matriz[:,1] > 0]

# Agora, indexemos a matriz
matriz[matriz[:,1] > 0, :]

"""__________
___________

## Vamos praticar?

Em grupos, resolvam os exercícios a seguir.

**1.** Em uma **análise de regressão**, usualmente estamos interessados em descrever relações entre variáveis de um dado conjunto de dados por meio de uma **função** que descreva, o tanto quanto possível, estas relações.

Por exemplo, no gráfico abaixo, os pontos vermelhos relacionam as medidas das duas variáveis sendo avaliadas (nos eixos x e y); e a linha azul aproxima a relação entre elas por uma função linear.

![Normdist_regression.png](attachment:Normdist_regression.png)

É possível ver que nem todos os pontos obedecem exatamente à relação ditada pela reta (isto é, há pontos que não estão exatamente "sobre a reta"; mas, sim, ligeraimente acima, ou abaixo, dela). Isto, contudo, é esperado em um modelo de regressão, por inúmeras fontes de incerteza associadas às medições.

Uma das métricas que utilizamos para avaliar a qualidade de uma regressão é o **erro quadrático médio (EQM)**, que mensura a diferença total entre cada predição da regressão ($y_{prediction}$; que no nosso caso seriam os valores de y para a reta azul) com o valor real de cada i-ésima medida ($y_{i}$; que no nosso caso seriam as coordenadas y para cada ponto vermelho do gráfico). O EQM pode ser definido como:

$EQM = \frac{1}{n}\sum_{i=1}^{n}(y_{prediction} - y_{i})^2$.

Isto posto, escreva uma função que calcule o EQM recebendo, como entrada, os vetores $y_{prediction}$ e $y_{i}$. Por exemplo, digamos que sua função se chame *calculate_eqm*, ela deve operar da seguinte forma:
"""

# dados dois arrays quaisquer de mesmo tamanho, a função deve retornar o EQM
y_prediction = np.array([1,2,3])
y_i = np.array([0,0,3])
#calculate_eqm(y_prediction,y_i)

# Solução

def func_eqm(y_prediction, y_i):
  func = ((y_prediction - y_i)**2).sum()/(len(y_prediction))
  return func


y_prediction = np.array([1,2,3])
y_i = np.array([0,0,3])
a = func_eqm(y_prediction, y_i)
print(a)

def calculate_eqm(y_prediction, y_i):
  return ((y_prediction - y_i)**2).sum()/(len(y_prediction))

"""**2.** A eletroencefalografia (EEG) é uma técnica que mensura potenciais elétricos cerebrais em diversas regiões do escalpo do paciente. Suponha que você recebeu um conjunto de dados na forma de uma matriz de 64 x 512 elementos, em que cada linha contém o sinal gravado em um dos **eletrodos** espalhados pelo escalpo em um exame de EEG, e cada coluna contém um valor de potencial elétrico, em microvolts.

Como o sinal de EEG é muito suscetível a ruídos externos (interferências na qualidade do sinal), uma operação comum para atenuar a interferência no sinal consiste em tirar a média do potencial elétrico de todos os eletrodos, e subtrair este valor de cada um deles. Isto atenua fontes de ruído ao sinal comuns a todos os eletrodos. Em termos matemáticos, o sinal processado por esta operação, $X_{e,i}$ para cada eletrodo (e) e amostra (i), é dado por:

$X_{e,i} = \hat{X_{e,i}} - \frac{1}{N}\sum_{e=1}^{N}\hat{X_{e,i}}$,

em que $\hat{X_{e,i}}$ representa o sinal original (ou seja, é a matriz de entrada de 64 x 512 elementos), e $N$ indica o total de eletrodos.

Com o exposto acima, escreva uma função que retorne uma matriz com os sinais de EEG processados conforme a operação mencionada. Sua função deve operar conforme o exemplo abaixo.
"""

# vamos supor uma matriz de entrada gerada por dados aleatórios
X = np.random.randn(64,512)
X.shape # apenas para verificar as dimensões

# a função deve executar a operação equacionada anteriormente, retornando uma nova matriz
X_processado = process_EEG_signal(X)
X_processado.shape

# Somando as diferenças entre cada elemento das duas matrizes, apenas para ilustrar que elas não são iguais
(X_processado - X).sum()

# Visualizando as matrizes, para verificar uma vez mais que, de fato, os elementos são diferentes
X

# Matriz após o processamento descrito no enunciado
X_processado

# Solução
def func_eeg(matriz):
  eeg = (matriz_x) - (matriz_x).sum()/(len(matriz_x))
  return eeg

matriz_x = np.random.randn(64,512)
resultado = func_eeg(matriz_x)
#Para efeito comparativo ao resultado, mostrando que são valores diferentes
print(matriz_x)
#Resultado 
print(resultado)
#Mostrar que a matriz possui o mesmo tamanho
print(resultado.shape)

"""**3.** Em estatística, um **outlier** é um valor que destoa consideravelmente da distribuição à qual está associado. Um dos critérios para idenficar outliers consiste em encontrar a **distância interquantil** (IQR), ou seja, a diferença entre o terceiro (Q3) e o primeiro quartis (Q1) da distribuição, e tomar como outliers todos os pontos abaixo de 1.5*IQR - Q1, ou acima de 1.5*IQR + Q3.

<img src = "https://blog.curso-r.com/images/posts/banner/outlier.webp" />

Escreva uma função que, dada uma matriz de dados de entrada de dimensões $N_{observações} \times N_{features}$ retorne três requisitos: 
- uma matriz booleana indicando a existência de outliers nos dados de entrada;
- a quantidade de outliers
- quem são os outliers (os valores).

**Algumas definições:**
- um *quantil* divide a distribuição, após ordenados os pontos, segundo algum ponto de corte;
- o **primeiro quartil** é o ponto para o qual 25 % dos valores da distribuição estão abaixo dele;
- o **terceiro quartil** é o ponto para o qual 75 % dos valores da distribuição estão abaixo dele.

Pode ser útil consultar a função **numpy.quantile**.

Exemplo de operação da função:
"""

# Geremos um conjunto de dados qualquer
X = np.random.randn(300,15)
X

# identificamos os requisitos com nossa com nossa função "locate_outliers"
is_outlier, outliers_count, outliers = locate_outliers(X)

is_outlier

outliers_count

outliers

# Solução

matriz_out = np.random.randn(300,15)
q1 = np.quantile(matriz_out, 0.25)
q3 = np.quantile(matriz_out, 0.75)

# Solução
def func_outliers(matriz):
  q1 = np.quantile(matriz, 0.25)
  q3 = np.quantile(matriz, 0.75)
  if np.any(matriz_out < q1) == True or np.any(matriz_out > q3) == True:
    #Mostrar se possuem outliers
    print("´Possui Outliers")
    q1_filtro = matriz_out[matriz_out < q1]
    q3_filtro = matriz_out[matriz_out > q3]
    q_valores = np.concatenate((q1_filtro,q3_filtro), axis = 0)
    count_outliers = np.count_nonzero(((matriz_out < q1) | (matriz_out > q3) ))
    #O total de outliers
    print(f'O total de outliers: {count_outliers}')
    #Mostrar os valores outliers
    print(f'Os valores dos outliers: {q_valores}')

